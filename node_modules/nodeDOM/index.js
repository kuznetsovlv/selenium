(function () {
	"use strict";

	var ExtArr = require('./lib/extarr.js');
	var FrozenArr = require('./lib/frozenarr.js');
	var Attributes = require('./lib/attributes.js');
	var CONSTANTS = require('./lib/constants.js');
	var DataSet = require('./lib/dataset.js');
	var Output = require('./lib/output.js');

	var contanerTypes = [CONSTANTS.ELEMENT_NODE, CONSTANTS.DOCUMENT_NODE, CONSTANTS.DOCUMENT_FRAGMENT_NODE];

	/*Constructors*/

	function Node (tag, type) {
		/*Properties*/
		Object.defineProperties(this, {
			'tag': {value: contanerTypes.indexOf(type) >= 0 || type === CONSTANTS.DOCUMENT_TYPE_NODE ? tag : '', writable: false, enumerable: true, configurable: false},
			'nodeName': {get: function () {
				var doctype = (this.ownerDocument || this).doctype;
				return contanerTypes.indexOf(type) >= 0 ? ((doctype ? /html/i.test(doctype.name) : false) ? tag.toUpperCase() : tag) : '';
			}, enumerable: true, configurable: false},
			'nodeType': {value: type, writable: false, enumerable: true, configurable: false},
			'parentNode': {value: null, writable: true, enumerable: true, configurable: false},
			'childNodes': {value: new ExtArr(), writable: false, enumerable: true, configurable: false},
			'firstChild': {get: function () {return this.childNodes[0] || null;}, enumerable: true, configurable: false},
			'lastChild': {get: function () {return this.childNodes.last || null;}, enumerable: true, configurable: false},
			'nextSibling': {get: function () {
				if (!this.parentNode)
					return null;
				return this.parentNode.childNodes[this.parentNode.childNodes.position(this) + 1] || null;
			}, enumerable: true, configurable: false},
			'previousSibling': {get: function () {
				if (!this.parentNode)
					return null;
				return this.parentNode.childNodes[this.parentNode.childNodes.position(this) - 1] || null;
			}, enumerable: true, configurable: false},
			'nodeValue': {value: [CONSTANTS.TEXT_NODE, CONSTANTS.COMMENT_NODE].indexOf(type) >= 0 && ( tag || tag === 0 || tag === false) ? tag : '', writable: true, enumerable: true, configurable: false},
			'ownerDocument': {
				get: function () {
					if (this.nodeType === CONSTANTS.DOCUMENT_NODE)
						return null;
					return this._ownerDocument || null;
				},
				set: function (v) {
					if (this._ownerDocument || !v)
						return;
					Object.defineProperty(this, '_ownerDocument', {value: v, writable: false, enumerable: false, configurable: true});
				}, enumerable: true, configurable: false
			},
			'textContent': {
				get: function () {
					switch (this.nodeType) {
						case CONSTANTS.TEXT_NODE:
						case CONSTANTS.COMMENT_NODE: return this.nodeValue; /*this.data*/
						case CONSTANTS.ELEMENT_NODE:
						case CONSTANTS.DOCUMENT_FRAGMENT_NODE: var str = [];
							for (var i = 0, l = this.childNodes.length; i < l; ++i)
								str.push(this.childNodes[i].textContent);
							return str.join(' ');
					}
				},
				set: function (v) {
					if (v.nodeType)
						v = v.textContent;
					else if (typeof v === 'object')
						v = v.toString();
					else
						v = '' + v;
					switch (this.nodeType) {
						case CONSTANTS.ELEMENT_NODE:
						case CONSTANTS.DOCUMENT_FRAGMENT_NODE: while (this.childNodes.length) this.childNodes.shift(); this.childNodes.push(text(v));
					}
				}, enumerable: true, configurable: false
			}
		});
	}
	Object.defineProperties(Node.prototype, {
		'appendChild': {
			value: function (elem) {
				if (elem.nodeType === CONSTANTS.DOCUMENT_FRAGMENT_NODE)
					while (elem.childNodes.length)
						this.appendChild(elem.childNodes[0]);
				if (elem.parentNode)
					elem.parentNode.removeChild(elem);
				this.childNodes.push(elem);
				elem.parentNode = this;
				elem.ownerDocument = this.ownerDocument;
				return elem;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'cloneNode': {
			value: function (deep) {
				var clone;
				switch (this.nodeType) {
					case CONSTANTS.DOCUMENT_NODE: clone = this.implementation.createDocument(); break;
					case CONSTANTS.DOCUMENT_FRAGMENT_NODE: clone = this.ownerDocument.createDocumentFragment(); break;
					case CONSTANTS.ELEMENT_NODE: clone = this.ownerDocument.createElement(this.tag); break;
					case CONSTANTS.TEXT_NODE: clone = this.ownerDocument.createTextNode(this.nodeValue); break;
					case CONSTANTS.COMMENT_NODE: clone = this.ownerDocument.createComment(this.nodeValue); break;
				}
				if (this.attributes) {
						for (var i = 0, attrs = this.attributes, l = attrs.length; i < l; ++i) {
							var attr = attrs[i];
							clone.setAttribute(attr.localName, attr.value);
						}
				}
				if (deep)
					for (var i = 0, l = this.childNodes.length; i < l; ++i)
						clone.appendChild(this.childNodes[i].cloneNode(deep));
				return clone;
			},writable: false, enumerable: true, configurable: false
		},
		'compareDocumentPosition': {
			value:function (other) {
				if (this === other)
					return CONSTANTS.DOCUMENT_POSITION_SAME;
				if ((this.ownerDocument || null) !== (other.ownerDocument || null))
					return CONSTANTS.DOCUMENT_POSITION_DISCONNECTED;
				if (this.nodeType === CONSTANTS.DOCUMENT_NODE)
					return CONSTANTS.DOCUMENT_POSITION_DISCONNECTED;
				var document = this.ownerDocument,
				    nodes = document.embeds,
				    compare, tmp;
				if (nodes.position(other) < nodes.position(this)) {
					compare = CONSTANTS.DOCUMENT_POSITION_PRECEDING;
					tmp = this;
					while (tmp = tmp.parentNode) {
						if (tmp = other)
							return compare && CONSTANTS.DOCUMENT_POSITION_CONTAINS;
					}
				} else {
					compare = CONSTANTS.DOCUMENT_POSITION_FOLLOWING;
					tmp = other;
					while (tmp = tmp.parentNode) {
						if (tmp = this)
							return compare && CONSTANTS.DOCUMENT_POSITION_CONTAINED_BY;
					}
				}
				return compare;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'hasChildNodes': {value: function () {return !!this.childNodes.length;}, writable: false, enumerable: true, configurable: false},
		'insertBefore': {
			value: function (newChild, refChild) {
				if (refChild && this.childNodes.position(refChild) === undefined)
					throw "refChild is not a child node";
				if ((newChild.ownerDocument !== this.ownerDocument) && (newChild.ownerDocument !== this))
					return undefined;
				if (newChild.nodeType === CONSTANTS.DOCUMENT_FRAGMENT_NODE)
					while (elem.childNodes.length)
						this.insertBefore(newChild.childNodes[0], refChild);
				if (newChild.parentNode)
					newChild.parentNode.removeChild(elem);
				if (!refChild) {
					this.appendChild(newChild);
				} else {
					this.childNodes.insertBefore(newChild, refChild);
					newChild.parentNode = this;
					newChild.ownerDocument = this.ownerDocument;
				}
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'isEqualNode': {
			value: function (other) {
				if (this === other)
					return true;
				if (this.nodeType !== other.nodeType || this.tag !== other.tag || this.nodeValue !== other.nodeValue)
					return false;
				if ((this.attributes && !other.attributes) || (other.attributes && !this.attributes))
					return false;
				else if (this.attributes && this.attributes.toString() !== other.attributes.toString())
					return false;
				if (this.childNodes.length !== other.childNodes.length)
					return false;
				for (var i = 0, l = this.childNodes.length; i < l; ++i)
					if (!this.childNodes[i].isEqual(other.childNodes[i]))
						return false;
				return true;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'isSameNode': {
			value: function (other) {return this === other;}, writable: false, enumerable: true, configurable: false
		},
		'normalize': {
			value: function () {
				var prev = null;
				for (var i = 0, l = this.childNodes.length; i < l; ++i) {
					var n = this.childNodes[i];
					if (n.nodeType === CONSTANTS.TEXT_NODE) {
						if (!prev) {
							prev = this.removeChild(n);
							if (!prev.nodeValue)
								prev = null;
						} else {
							prev = text(prev.nodeValue + n.nodeValue);
							this.removeChild(n);
						}
					} else if (prev) {
						this.insertBefore(prev, n);
						prev = null;
						}
					}
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'removeChild': {
			value: function (elem) {
				if (!this.childNodes.remove(elem))
					throw "Can not remove element which is not child";
				elem.parentNode = null;
				return elem;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'replaceChild': {
			value: function (newChild, oldChild) {
				this.insertBefore(newChild, oldChild);
				this.removeChild(oldChild);
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'toString': {
			value: function () {
				var str;
				switch (this.nodeType) {
					case CONSTANTS.ELEMENT_NODE:
						str = '<' + this.tag;
						if (this.attributes.length)
							str += (' ' + this.attributes);
						if (!this.childNodes.length)
							return str + '/>';
						str += '>';
						for (var i = 0, l = this.childNodes.length; i < l; ++i)
							str += this.childNodes[i];
						return str + '</' + this.tag + '>';
					case CONSTANTS.TEXT_NODE: return this.nodeValue;
					case CONSTANTS.COMMENT_NODE: return '<!--' + this.nodeValue + '--!>';
					case CONSTANTS.DOCUMENT_NODE:
					case CONSTANTS.DOCUMENT_FRAGMENT_NODE:
						str = [];
						for (var i = 0, l = this.childNodes.length; i < l; ++i)
							str.push(this.childNodes[i].toString());
						return str.join('\n');
				}
			},
			writable: false,
			enumerable: false,
			configurable: false
		}
	});

	function Element (tag, type) {
		var node = new Node(tag, type || CONSTANTS.ELEMENT_NODE);
		for (var key in node) {
			if(!node.hasOwnProperty(key))
				continue;
			Object.defineProperty(this, key, Object.getOwnPropertyDescriptor(node, key));
		}
		Object.defineProperties(this, {
			'attributes': {value: new Attributes(), writable: false, enumerable: true, configurable: false},
			'childElementCount': {get: function () {return this.children.length}, enumerable: true, configurable: false},
			'children': {get: function () {
				var elements = new FrozenArr(),
				    nodes = this.childNodes;
				for (var i = 0, l = nodes.length; i < l; ++i) {
					var node = nodes[i];
					if (node.nodeType === CONSTANTS.ELEMENT_NODE)
						elements.push(node);
				}
				return elements.clear();
			}, enumerable: true, configurable: false},
			'classList': {get: function () {return this.attributes.getClassList();}, enumerable: true, configurable: false},
			'className': {
				get: function () {
					return this.classList.toString();
				},
				set: function (str) {
					this.attributes.set('class', str);
				},
				enumerable: true,
				configurable: false
			},
			'dataset': {
				get: function () {return new DataSet(this);},
				set: function (data) {
					var attrs = this.attributes,
					    _data = {};
					for (var key in data)
						_data[key] = data[key];
					for (var key in attrs)
						if (/^data\-\w+$/.test(key))
							attrs.remove(key);
					for (var key in _data)
						attrs.set(['data', key].join('-'), _data[key]);
				},
				enumerable: true,
				configurable: false
			},
			'firstElementChild': {get: function () {return this.children[0] || null;}, enumerable: true, configurable: false},
			'id': {
				get: function () {
					return this.attributes.id.value || null;
				},
				set: function (id) {
					this.attributes.set('id', id);
				},
				enumerable: true,
				configurable: false
			},
			'innerHTML': {
				get: function () {
					var str = [];
					for (var i = 0, l = this.childNodes.length; i < l; ++i)
						str.push(this.childNodes[i].toString());
					return str.join('');
				},
				enumerable: true,
				configurable: false
			},
			'lastElementChild': {get: function () {return this.children.last || null;}, enumerable: true, configurable: false},
			'localName': {get: function () {return this.tag;}, enumerable: true, configurable: false},
			'nextElementSibling': {get: function () {
				if (!this.parentNode)
					return null;
				return this.parentNode.children[this.parentNode.children.position(this) + 1] || null;
			}, enumerable: true, configurable: false},
			'outerHTML': {get: function () {return this.toString();}, enumerable: true, configurable: false},
			'previousElementSibling': {get: function () {
				if (!this.parentNode)
					return null;
				return this.parentNode.children[this.parentNode.children.position(this) - 1] || null;
			}, enumerable: true, configurable: false},
			'tagName': {get: function () {return this.nodeName;}, enumerable: true, configurable: false},
			'title': {
				get: function () {
					var t = this.attributes.get('title');
					return t ? t.value : '';
				},
				set: function (title) {
					this.attributes.set('title', title);
				},
				enumerable: true,
				configurable: false
			}
		});
	}

	Object.defineProperties(Element.prototype, {
		'getAttribute': {
			value: function (qualifiedName) {
				var attr = this.attributes.get(qualifiedName);
				return attr ? attr.value : null;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'getElementsByClassName': {
			value: function (classNames) {
				_classNames = classNames.split(' ');
				var res = [];
				m: for (var i = 0, l = this.children.length; i < l; ++i) {
					var elem = this.children[i],
					    classList = elem.classList;
					for (var j = 0, n = _classNames.length; j < n; ++j)
						if (!classList.contains(_classNames[j]))
							break m;
					res.push(elem);
					res = res.concat(elem.getElementsByClassName(classNames));
				}
				return res;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'getElementsByTagName': {
			value: function (qualifiedName) {
				var res = [];
				for (var i = 0, l = this.children.length; i < l; ++i) {
					var elem = this.children[i];
					if (elem.tag === qualifiedName)
						res.push(elem);
					res = res.concat(elem.getElementsByTagName(qualifiedName));
				}
				return res;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'hasAttribute': {
			value: function (qualifiedName) {
				return !!this.attributes[qualifiedName];
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'insertAdjacentHTML': {
			value: function (position, text) {
				text = new Text(text);
				switch (position) {
					case 'beforebegin': this.parentNode.insertBefore(text, this); break;
					case 'afterend': this.parentNode.insertBefore(text, this.nextSibling); break;
					case 'afterbegin': this.insertBefore(text, this.firstChild); break;
					case 'beforeend': this.appendChild(text); break;
				}
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'removeAttribute': {
			value: function (qualifiedName) {
				if (qualifiedName.toLowerCase() === 'classname')
					qualifiedName = 'class';
				this.attributes.remove(qualifiedName);
				if (qualifiedName.toLowerCase() === 'class')
					qualifiedName = 'className';
				if (!{id: 1, className: 1, title: 1}[qualifiedName])
					delete this[qualifiedName];
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'setAttribute': {
			value: function (qualifiedName, value) {
				if (qualifiedName.toLowerCase() === 'classname')
					qualifiedName = 'class';
				this.attributes.set(qualifiedName, value);
				if (qualifiedName.toLowerCase() === 'class')
					qualifiedName = 'className';
				if (!{id: 1, className: 1, title: 1}[qualifiedName])
					Object.defineProperty(this, qualifiedName, {
						get: function () {return this.attributes[qualifiedName].value},
						set: function (value) {this.attributes.set(qualifiedName, value)},
						enumerable: true,
						configurable: true
					});
			}
		},
		'toString': Object.getOwnPropertyDescriptor(Node.prototype, 'toString')
	});
		

	function Text (value) {
		var node = new Node(value, CONSTANTS.TEXT_NODE);
		for (var key in node) {
			if(!node.hasOwnProperty(key) && !{childNodes: 1, firstChild: 1, lastChild: 1}[key])
				continue;
			Object.defineProperty(this, key, Object.getOwnPropertyDescriptor(node, key));
		}
		Object.defineProperties(this, {
			'data': {
				get: function () {return this.nodeValue},
				set: function (text) {this.nodeValue = text},
				enumerable: true,
				configurable: false
			},
			'length': {
				get: function () {
					return this.nodeValue.length;
				},
				enumerable: true,
				configurable: false
			},
			'wholeText': {
				get: function () {
					if (this.previousSibling && this.previousSibling.nodeType === CONSTANTS.TEXT_NODE)
						return this.previousSibling.wholeText;
					var text = [this.data],
					    e = this;
					while ((e = e.nextSibling) && e.nodeType === CONSTANTS.TEXT_NODE)
						text.push(e.data);
					return test.join('');
				},
				enumerable: true,
				configurable: false
			}
		});
	}

	Object.defineProperty(Text.prototype, 'toString', Object.getOwnPropertyDescriptor(Node.prototype, 'toString'));

	function Comment (value) {
		var node = new Node(value, CONSTANTS.COMMENT_NODE);
		for (var key in node) {
			if(!node.hasOwnProperty(key) && !{childNodes: 1, firstChild: 1, lastChild: 1}[key])
				continue;
			Object.defineProperty(this, key, Object.getOwnPropertyDescriptor(node, key));
		}
	}

	Object.defineProperty(Comment.prototype, 'toString', Object.getOwnPropertyDescriptor(Node.prototype, 'toString'));

	function DocumentFragment () {
		var node = new Node('', CONSTANTS.DOCUMENT_FRAGMENT_NODE);
		for (var key in node) {
			if(!node.hasOwnProperty(key))
				continue;
			Object.defineProperty(this, key, Object.getOwnPropertyDescriptor(node, key));
		}
	}

	Object.defineProperty(DocumentFragment.prototype, 'toString', {value: function () {
		var strs = [];
		for (var i = 0, l = this.childNodes.length; i < l; ++i)
			strs.push(this.childNodes[i].toString());
		return strs.join('\n');
	}})

	for (var key in Node.prototype) {
		Object.defineProperty(Element.prototype, key, Object.getOwnPropertyDescriptor(Node.prototype, key));
		Object.defineProperty(DocumentFragment.prototype, key, Object.getOwnPropertyDescriptor(Node.prototype, key));
		if ({appendChild: 1, hasChildNodes: 1, insertBefore: 1, normalize: 1, removeChild: 1, replaceChild: 1}[key])
			continue;
		Object.defineProperty(Text.prototype, key, Object.getOwnPropertyDescriptor(Node.prototype, key));
		Object.defineProperty(Comment.prototype, key, Object.getOwnPropertyDescriptor(Node.prototype, key));
	}

		function DocumentType (name, publicId, systemId) {
			var node = new Node('!DOCTYPE', CONSTANTS.DOCUMENT_TYPE_NODE);
		for (var key in node) {
			if(!node.hasOwnProperty(key))
				continue;
			Object.defineProperty(this, key, Object.getOwnPropertyDescriptor(node, key));
		}
		Object.defineProperties(this, {
			'name': {value: name, writable: false, enumerable: true, configurable: false},
			'publicId': {value: publicId || '', writable: false, enumerable: true, configurable: false},
			'systemId': {value: systemId || '', writable: false, enumerable: true, configurable: false}
		});
	}

	Object.defineProperty(DocumentType.prototype, 'toString', {
		value: function () {
			return "<" + this.tag + " " + this.name + (this.publicId ? " PUBLIC \"" + this.publicId + "\"" : "") + (this.systemId ? " \"" + this.systemId + "\"" : "") + ">";
		},
		writable: false,
		enumerable: false,
		configurable: false
	});

	function Document (type, publicId, systemId) {
		var elem = new Element ('document', CONSTANTS.DOCUMENT_NODE);
		for (var key in elem) {
			if(!elem.hasOwnProperty(key) || {title: 1}[key])
				continue;
			Object.defineProperty(this, key, Object.getOwnPropertyDescriptor(elem, key));
		}
		Object.defineProperties(this, {
			'body': {
				get: function () {
					var html = this.documentElement;
					if (!html)
						return undefined;
					for (var i = 0, htmls = html.children, l = htmls.length; i < l; ++i) {
						if (htmls[i].tag === 'body')
							return htmls[i];
					}
					return undefined
				},
				enumerable: false,
				configurable: false
			},
			'characterSet': {
				get: function () {return this.charset;}, enumerable: true, configurable: false
			},
			'charset': {
				get: function () {
					var meta = this.getElementsByTagName('meta'),
					    defaultCharset = 'UTF-8';
					for (var i = 0, l = meta.length; i < l; ++i)
						if (meta[i].getAttribute('charset'))
							return meta[i].getAttribute('charset');
					this.charset = defaultCharset;
					return defaultCharset;
				},
				set: function (v) {
					var meta = this.getElementsByTagName('meta');
					for (var i = 0, l = meta.length; i < l; ++i)
						if (meta[i].getAttribute('charset')) {
							meta[i].setAttribute('charset', v);
							return;
						}
					meta = meta[0];
					if (!meta) {
						var head = this.getElementsByTagName('head')[0];
						meta = this.createElement('meta');
						head.insertBefore(meta, head.firstChild);
					}
					meta.setAttribute('charset', v);
				},
				enumerable: true,
				configurable: false
			},
			'dir': {
				get: function () {
					var html = this.documentElement;
					if (!html)
						return undefined;
					return html.getAttribute('dir');
				},
				set: function (v) {
					this.documentElement.setAttribute('dir', v);
				},
				enumerable: true,
				configurable: false
			},
			'doctype': {
				get: function () {
					for (var i = 0, children = this.childNodes, l = children.length; i < l; ++i)
						if (children[i].nodeType === CONSTANTS.DOCUMENT_TYPE_NODE)
							return children[i];
					return undefined;
				},
				enumerable: true,
				configurable: false
			},
			'documentElement': {
				get: function () {
					return this.firstElementChild;
				},
				enumerable: true,
				configurable: false
			},
			'embeds': {
				get: function () {
					var n = new FrozenArr();
					function _scan (node) {
						n.push(node);
						var c = node.childNodes;
						for (var i = 0, l = c.length; i < l; ++i)
							_scan(c[i]);
						return n;
					}
					return _scan(this).clear();
				},
				enumerable: true,
				configurable: false
			},
			'forms': {
				get: function () {
					return this.getElementsByTagName('form');
				},
				enumerable: true,
				configurable: false
			},
			'head': {
				get: function () {
					var html = this.documentElement;
					if (!html)
						return undefined;
					for (var i = 0, htmls = html.children, l = htmls.length; i < l; ++i) {
						if (htmls[i].tag === 'head')
							return htmls[i];
					}
					return undefined
				},
				enumerable: true,
				configurable: false
			},
			'images': {
				get: function () {
					return this.getElementsByTagName('img');
				},
				enumerable: true,
				configurable: false
			},
			'links': {
				get: function () {
					var links = new FrozenArr();
					for (var i = 0, embeds = this.embeds, l = embeds.length; i < l; ++i) {
						var e = embeds[i];
						if (e.tag !== 'link' && e.hasAttribute('href'))
							links.push(e);
					}
					return links.clear();
				},
				enumerable: true,
				configurable: false
			},
			'plugins': {get: function () {return this.embeds}, enumerable: true, configurable: false},
			'scripts': {
				get: function () {
					return this.getElementsByTagName('script');
				},
				enumerable: true,
				configurable: false
			},
			'title': {
				get: function () {
					var head = this.head;
					if (!head)
						return undefined;
					for (var i = 0, heads = head.children, l = heads.length; i < l; ++i) {
						if (heads[i].tag === 'title')
							return heads[i].innerHTML;
					}
					return undefined
				},
				set: function (v) {
					var head = this.head,
					    title = this.createElement('title');
					title.appendChild(this.createTextNode(v));
					if (!head)
						return;
					for (var i = 0, heads = head.children, l = heads.length; i < l; ++i) {
						if (heads[i].tag === 'title') {
							head.replaceChild(title, heads[i]);
							return;
						}
					}
					head.appendChild(title);
				},
				enumerable: true,
				configurable: false
			}
		});
		if (type)
			this.appendChild(new DocumentType(type, publicId, systemId));
	}

	for (var key in Element.prototype) {
		if ({appendChild: 1, insertBefore: 1}[key])
			continue;
		Object.defineProperty(Document.prototype, key, Object.getOwnPropertyDescriptor(Element.prototype, key));
	}
	Object.defineProperties(Document.prototype, {
		'adoptNode' : {
			value: function (node) {
				node.parentNode.removeChild(node);
				Object.defineProperty(node, '_ownerDocument', {value: this, writable: false, enumerable: false, configurable: true});
			}
		},
		'appendChild': {
			value: function (elem) {
				for (var i = 0, l =this.childNodes; i < l; ++i)
					if (this.childNodes[i].nodeType === elem.nodeType)
						throw "Only one node of this type can be presented";
				Element.prototype.appendChild.call(this, elem);
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'createComment': {
			value: function (data) {
				var c = new Comment(data);
				c.ownerDocument = this;
				return c;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'createDocumentFragment': {
			value: function () {
				var f = new DocumentFragment();
				f.ownerDocument = this;
				return f;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'createElement': {
			value: function (tag) {
				var elem = new Element(tag, CONSTANTS.ELEMENT_NODE);
				elem.ownerDocument = this;
				return elem;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'createTextNode': {
			value: function (data) {
				var text = new Text(data);
				text.ownerDocument = this;
				return text;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'insertBefore': {
			value: function (newChild, refChild) {
				for (var i = 0, l =this.childNodes; i < l; ++i)
					if (this.childNodes[i].nodeType === elem.nodeType)
						throw "Only one node of this type can be presented";
				Element.prototype.insertBefore.call(this, newChild, refChild);
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'getElementById': {
			value: function (elementId) {
				for (var i = 0, embeds = this.embeds, l = embeds.length; i < l; ++i)
					if (embeds[i].id == elementId)
						return embeds[i];
				return null;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'getElementsByName': {
			value: function (qualifiedName) {
				var res = [];
				for (var i = 0, embeds = this.embeds, l = embeds.length; i < l; ++i) {
					var e = embeds[i];
					if (e.name == qualifiedName)
						res.push(e);
				}
				return res;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'importNode': {
			value: function (node, deep) {
				node = node.cloneNode(deep);
				Element.prototype.appendChild.call(this, elem);
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'toString': Object.getOwnPropertyDescriptor(Node.prototype, 'toString'),
		'drawElement': {
			value: function (element, path, format) {
				var output = new Output(path, (element.ownerDocument || element).charset || this.charset);
				function _draw(elem, format, t) {
					var tabs = [];
					if (!t)
						t = 0;
					for (var i = 0; i < t; ++i)
						tabs.push('\t');
					tabs = tabs.join('');

					switch (format) {
						case 'selenium': t = (elem.tag === 'tr' && 1) || 0; break;
						case 'normal':
						default: ++t; break;
					}

					switch (elem.nodeType) {

						case CONSTANTS.DOCUMENT_NODE:
						case CONSTANTS.DOCUMENT_FRAGMENT_NODE:
							for (var i = 0, l = elem.childNodes.length; i < l; ++i)
								_draw(elem.childNodes[i], format, 0);
							break;

						case CONSTANTS.ELEMENT_NODE:
							if (elem.childNodes.length === 1 && elem.firstChild.nodeType === CONSTANTS.TEXT_NODE) {
								output.printLine(tabs + elem.toString());
								return;
							}
							var str = '<' + elem.tag;
							if (elem.attributes.length)
								str += (' ' + elem.attributes);
							output.printLine(tabs + str + (elem.childNodes.length ? '>' : '/>'));
								
							for (var i = 0, l = elem.childNodes.length; i < l; ++i)
								_draw(elem.childNodes[i], format, t);
							if (elem.childNodes.length)
								output.printLine(tabs + '</' + elem.tag + '>');
							break;

						case CONSTANTS.TEXT_NODE:
						case CONSTANTS.COMMENT_NODE:
						case CONSTANTS.DOCUMENT_TYPE_NODE:
						default: output.printLine(tabs + elem.toString()); break;
					}
				}
				switch (format) {
					case 'oneline': output.printLine(element.toString()); break;
					default: _draw(element, format, 0);
				}
				
			},
			writable: false,
			enumerable: false,
			configurable: false
		},
		'drawDocument': {
			value: function (path, format, xmlInfo) {
				if (xmlInfo) {
					var self = this,
					    data = typeof xmlInfo === 'object' ? xmlInfo : {},
					    info = {
					    	nodeType: -1,
					    	ownerDocument: self,
					    	data: data,
					    	toString: function() {
					    		var str = ['<?xml'];
					    		for (var key in this.data)
					    			str.push(key + '=\"' + this.data[key] + '\"');
					    		str.push('?>');
					    		return str.join(' ');
					    	}
					    };
					data.version = data.version || this.version || '1.0';
					data.encoding = (data.encoding || this.charset || 'UTF-8');
					this.insertBefore(info, this.firstChild);
				}
				this.drawElement(this, path, format);
			},
			writable: false,
			enumerable: false,
			configurable: false
		}
	});

	function DOMImplementation () {

	}

	Object.defineProperties(DOMImplementation.prototype, {
		'createDocument': {
			value: function (namespace, qualifiedName, doctype) {
				var document = new Document ();
				if (doctype) {
					document.appendChild(doctype);
				}
				if (qualifiedName) {
					var elem = new Element (qualifiedName);
					document.appendChild(elem);
				}
				Object.defineProperty(document, 'implementation', {value: this, writable: false, enumerable: true, configurable: false});
				return document;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'createDocumentType' : {
			value: function (qualifiedName, publicId, systemId) {
				return new DocumentType (qualifiedName, publicId, systemId);
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'createHTMLDocument': {
			value: function (title, doctype) {
				var document = this.createDocument(null, 'html', doctype || this.createDocumentType('html')),
				    fragment = document.createDocumentFragment(),
				    head = document.createElement('head'),
				    t = document.createElement('title'),
				    meta = document.createElement('meta');
				t.appendChild(document.createTextNode(title));
				head.appendChild(meta);
				head.appendChild(t);
				fragment.appendChild(head);
				fragment.appendChild(document.createElement('body'));
				document.getElementsByTagName('html')[0].appendChild(fragment);
				meta.setAttribute('content', 'text/html');
				meta.setAttribute('charset', document.charset);
				return document;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'createSVGDocument': {
			value: function (doctype) {
				return this.createDocument(null, 'svg', doctype || this.createDocumentType('svg'));
			},
			writable: false,
			enumerable: true,
			configurable: false
		}
	});

	module.exports = DOMImplementation;
}) ()