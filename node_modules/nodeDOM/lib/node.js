(function () {

	"use strict";

	var CONSTANTS = require('./constants.js');
	var ExtArr = require('./extarr.js');

	var contanerTypes = [CONSTANTS.ELEMENT_NODE, CONSTANTS.DOCUMENT_NODE, CONSTANTS.DOCUMENT_FRAGMENT_NODE];

	function Node (tag, type) {
		/*Properties*/
		Object.defineProperties(this, {
			'tag': {value: contanerTypes.indexOf(type) >= 0 || type === CONSTANTS.DOCUMENT_TYPE_NODE ? tag : '', writable: false, enumerable: true, configurable: false},
			'nodeName': {get: function () {
				var doctype = (this.ownerDocument || this).doctype;
				return contanerTypes.indexOf(type) >= 0 ? ((doctype ? /html/i.test(doctype.name) : false) ? tag.toUpperCase() : tag) : '';
			}, enumerable: true, configurable: false},
			'nodeType': {value: type, writable: false, enumerable: true, configurable: false},
			'parentNode': {value: null, writable: true, enumerable: true, configurable: false},
			'childNodes': {value: new ExtArr(), writable: false, enumerable: true, configurable: false},
			'firstChild': {get: function () {return this.childNodes[0] || null;}, enumerable: true, configurable: false},
			'lastChild': {get: function () {return this.childNodes.last || null;}, enumerable: true, configurable: false},
			'nextSibling': {get: function () {
				if (!this.parentNode)
					return null;
				return this.parentNode.childNodes[this.parentNode.childNodes.position(this) + 1] || null;
			}, enumerable: true, configurable: false},
			'previousSibling': {get: function () {
				if (!this.parentNode)
					return null;
				return this.parentNode.childNodes[this.parentNode.childNodes.position(this) - 1] || null;
			}, enumerable: true, configurable: false},
			'nodeValue': {value: [CONSTANTS.TEXT_NODE, CONSTANTS.COMMENT_NODE].indexOf(type) >= 0 && ( tag || tag === 0 || tag === false) ? tag : '', writable: true, enumerable: true, configurable: false},
			'ownerDocument': {
				get: function () {
					if (this.nodeType === CONSTANTS.DOCUMENT_NODE)
						return null;
					return this._ownerDocument || null;
				},
				set: function (v) {
					if (this._ownerDocument || !v)
						return;
					Object.defineProperty(this, '_ownerDocument', {value: v, writable: false, enumerable: false, configurable: true});
				}, enumerable: true, configurable: false
			},
			'textContent': {
				get: function () {
					switch (this.nodeType) {
						case CONSTANTS.TEXT_NODE:
						case CONSTANTS.COMMENT_NODE: return this.nodeValue; /*this.data*/
						case CONSTANTS.ELEMENT_NODE:
						case CONSTANTS.DOCUMENT_FRAGMENT_NODE: var str = [];
							for (var i = 0, l = this.childNodes.length; i < l; ++i)
								str.push(this.childNodes[i].textContent);
							return str.join(' ');
					}
				},
				set: function (v) {
					if (v.nodeType)
						v = v.textContent;
					else if (typeof v === 'object')
						v = v.toString();
					else
						v = '' + v;
					switch (this.nodeType) {
						case CONSTANTS.ELEMENT_NODE:
						case CONSTANTS.DOCUMENT_FRAGMENT_NODE: while (this.childNodes.length) this.childNodes.shift(); this.childNodes.push(text(v));
					}
				}, enumerable: true, configurable: false
			}
		});
	}
	Object.defineProperties(Node.prototype, {
		'appendChild': {
			value: function (elem) {
				if (elem.nodeType === CONSTANTS.DOCUMENT_FRAGMENT_NODE)
					while (elem.childNodes.length)
						this.appendChild(elem.childNodes[0]);
				if (elem.parentNode)
					elem.parentNode.removeChild(elem);
				this.childNodes.push(elem);
				elem.parentNode = this;
				elem.ownerDocument = this.ownerDocument;
				return elem;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'cloneNode': {
			value: function (deep) {
				var clone;
				switch (this.nodeType) {
					case CONSTANTS.DOCUMENT_NODE: clone = this.implementation.createDocument(); break;
					case CONSTANTS.DOCUMENT_FRAGMENT_NODE: clone = this.ownerDocument.createDocumentFragment(); break;
					case CONSTANTS.ELEMENT_NODE: clone = this.ownerDocument.createElement(this.tag); break;
					case CONSTANTS.TEXT_NODE: clone = this.ownerDocument.createTextNode(this.nodeValue); break;
					case CONSTANTS.COMMENT_NODE: clone = this.ownerDocument.createComment(this.nodeValue); break;
				}
				if (this.attributes) {
						for (var i = 0, attrs = this.attributes, l = attrs.length; i < l; ++i) {
							var attr = attrs[i];
							clone.setAttribute(attr.localName, attr.value);
						}
				}
				if (deep)
					for (var i = 0, l = this.childNodes.length; i < l; ++i)
						clone.appendChild(this.childNodes[i].cloneNode(deep));
				return clone;
			},writable: false, enumerable: true, configurable: false
		},
		'compareDocumentPosition': {
			value:function (other) {
				if (this === other)
					return CONSTANTS.DOCUMENT_POSITION_SAME;
				if ((this.ownerDocument || null) !== (other.ownerDocument || null))
					return CONSTANTS.DOCUMENT_POSITION_DISCONNECTED;
				if (this.nodeType === CONSTANTS.DOCUMENT_NODE)
					return CONSTANTS.DOCUMENT_POSITION_DISCONNECTED;
				var document = this.ownerDocument,
				    nodes = document.embeds,
				    compare, tmp;
				if (nodes.position(other) < nodes.position(this)) {
					compare = CONSTANTS.DOCUMENT_POSITION_PRECEDING;
					tmp = this;
					while (tmp = tmp.parentNode) {
						if (tmp = other)
							return compare && CONSTANTS.DOCUMENT_POSITION_CONTAINS;
					}
				} else {
					compare = CONSTANTS.DOCUMENT_POSITION_FOLLOWING;
					tmp = other;
					while (tmp = tmp.parentNode) {
						if (tmp = this)
							return compare && CONSTANTS.DOCUMENT_POSITION_CONTAINED_BY;
					}
				}
				return compare;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'hasChildNodes': {value: function () {return !!this.childNodes.length;}, writable: false, enumerable: true, configurable: false},
		'insertBefore': {
			value: function (newChild, refChild) {
				if (refChild && this.childNodes.position(refChild) === undefined)
					throw "refChild is not a child node";
				if ((newChild.ownerDocument !== this.ownerDocument) && (newChild.ownerDocument !== this))
					return undefined;
				if (newChild.nodeType === CONSTANTS.DOCUMENT_FRAGMENT_NODE)
					while (elem.childNodes.length)
						this.insertBefore(newChild.childNodes[0], refChild);
				if (newChild.parentNode)
					newChild.parentNode.removeChild(elem);
				if (!refChild) {
					this.appendChild(newChild);
				} else {
					this.childNodes.insertBefore(newChild, refChild);
					newChild.parentNode = this;
					newChild.ownerDocument = this.ownerDocument;
				}
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'isEqualNode': {
			value: function (other) {
				if (this === other)
					return true;
				if (this.nodeType !== other.nodeType || this.tag !== other.tag || this.nodeValue !== other.nodeValue)
					return false;
				if ((this.attributes && !other.attributes) || (other.attributes && !this.attributes))
					return false;
				else if (this.attributes && this.attributes.toString() !== other.attributes.toString())
					return false;
				if (this.childNodes.length !== other.childNodes.length)
					return false;
				for (var i = 0, l = this.childNodes.length; i < l; ++i)
					if (!this.childNodes[i].isEqual(other.childNodes[i]))
						return false;
				return true;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'isSameNode': {
			value: function (other) {return this === other;}, writable: false, enumerable: true, configurable: false
		},
		'normalize': {
			value: function () {
				var prev = null;
				for (var i = 0, l = this.childNodes.length; i < l; ++i) {
					var n = this.childNodes[i];
					if (n.nodeType === CONSTANTS.TEXT_NODE) {
						if (!prev) {
							prev = this.removeChild(n);
							if (!prev.nodeValue)
								prev = null;
						} else {
							prev = text(prev.nodeValue + n.nodeValue);
							this.removeChild(n);
						}
					} else if (prev) {
						this.insertBefore(prev, n);
						prev = null;
						}
					}
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'removeChild': {
			value: function (elem) {
				if (!this.childNodes.remove(elem))
					throw "Can not remove element which is not child";
				elem.parentNode = null;
				return elem;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'replaceChild': {
			value: function (newChild, oldChild) {
				this.insertBefore(newChild, oldChild);
				this.removeChild(oldChild);
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'toString': {
			value: function () {
				var str;
				switch (this.nodeType) {
					case CONSTANTS.ELEMENT_NODE:
						str = '<' + this.tag;
						if (this.attributes.length)
							str += (' ' + this.attributes);
						if (!this.childNodes.length)
							return str + '/>';
						str += '>';
						for (var i = 0, l = this.childNodes.length; i < l; ++i)
							str += this.childNodes[i];
						return str + '</' + this.tag + '>';
					case CONSTANTS.TEXT_NODE: return this.nodeValue;
					case CONSTANTS.COMMENT_NODE: return '<!--' + this.nodeValue + '--!>';
					case CONSTANTS.DOCUMENT_NODE:
					case CONSTANTS.DOCUMENT_FRAGMENT_NODE:
						str = [];
						for (var i = 0, l = this.childNodes.length; i < l; ++i)
							str.push(this.childNodes[i].toString());
						return str.join('\n');
				}
			},
			writable: false,
			enumerable: false,
			configurable: false
		}
	});

	module.exports = Node;
})()