(function () {
	"use strict";

	var CONSTANTS = require('./constants.js');
	var Comment = require('./comment.js');
	var DocumentFragment = require('./documentfragment.js');
	var DocumentType = require('./documenttype.js');
	var Element = require('./element.js');
	var Node = require('./node.js');
	var Text = require('./text.js');


	var Output = require('./output.js');

	function Document (type, publicId, systemId) {
		var elem = new Element ('document', CONSTANTS.DOCUMENT_NODE);
		for (var key in elem) {
			if(!elem.hasOwnProperty(key) || {title: 1}[key])
				continue;
			Object.defineProperty(this, key, Object.getOwnPropertyDescriptor(elem, key));
		}
		Object.defineProperties(this, {
			'body': {
				get: function () {
					var html = this.documentElement;
					if (!html)
						return undefined;
					for (var i = 0, htmls = html.children, l = htmls.length; i < l; ++i) {
						if (htmls[i].tag === 'body')
							return htmls[i];
					}
					return undefined
				},
				enumerable: false,
				configurable: false
			},
			'characterSet': {
				get: function () {return this.charset;}, enumerable: true, configurable: false
			},
			'charset': {
				get: function () {
					var meta = this.getElementsByTagName('meta'),
					    defaultCharset = 'UTF-8';
					for (var i = 0, l = meta.length; i < l; ++i)
						if (meta[i].getAttribute('charset'))
							return meta[i].getAttribute('charset');
					this.charset = defaultCharset;
					return defaultCharset;
				},
				set: function (v) {
					var meta = this.getElementsByTagName('meta');
					for (var i = 0, l = meta.length; i < l; ++i)
						if (meta[i].getAttribute('charset')) {
							meta[i].setAttribute('charset', v);
							return;
						}
					meta = meta[0];
					if (!meta) {
						var head = this.getElementsByTagName('head')[0];
						meta = this.createElement('meta');
						head.insertBefore(meta, head.firstChild);
					}
					meta.setAttribute('charset', v);
				},
				enumerable: true,
				configurable: false
			},
			'dir': {
				get: function () {
					var html = this.documentElement;
					if (!html)
						return undefined;
					return html.getAttribute('dir');
				},
				set: function (v) {
					this.documentElement.setAttribute('dir', v);
				},
				enumerable: true,
				configurable: false
			},
			'doctype': {
				get: function () {
					for (var i = 0, children = this.childNodes, l = children.length; i < l; ++i)
						if (children[i].nodeType === CONSTANTS.DOCUMENT_TYPE_NODE)
							return children[i];
					return undefined;
				},
				enumerable: true,
				configurable: false
			},
			'documentElement': {
				get: function () {
					return this.firstElementChild;
				},
				enumerable: true,
				configurable: false
			},
			'embeds': {
				get: function () {
					var n = new FrozenArr();
					function _scan (node) {
						n.push(node);
						var c = node.childNodes;
						for (var i = 0, l = c.length; i < l; ++i)
							_scan(c[i]);
						return n;
					}
					return _scan(this).clear();
				},
				enumerable: true,
				configurable: false
			},
			'forms': {
				get: function () {
					return this.getElementsByTagName('form');
				},
				enumerable: true,
				configurable: false
			},
			'head': {
				get: function () {
					var html = this.documentElement;
					if (!html)
						return undefined;
					for (var i = 0, htmls = html.children, l = htmls.length; i < l; ++i) {
						if (htmls[i].tag === 'head')
							return htmls[i];
					}
					return undefined
				},
				enumerable: true,
				configurable: false
			},
			'images': {
				get: function () {
					return this.getElementsByTagName('img');
				},
				enumerable: true,
				configurable: false
			},
			'links': {
				get: function () {
					var links = new FrozenArr();
					for (var i = 0, embeds = this.embeds, l = embeds.length; i < l; ++i) {
						var e = embeds[i];
						if (e.tag !== 'link' && e.hasAttribute('href'))
							links.push(e);
					}
					return links.clear();
				},
				enumerable: true,
				configurable: false
			},
			'plugins': {get: function () {return this.embeds}, enumerable: true, configurable: false},
			'scripts': {
				get: function () {
					return this.getElementsByTagName('script');
				},
				enumerable: true,
				configurable: false
			},
			'title': {
				get: function () {
					var head = this.head;
					if (!head)
						return undefined;
					for (var i = 0, heads = head.children, l = heads.length; i < l; ++i) {
						if (heads[i].tag === 'title')
							return heads[i].innerHTML;
					}
					return undefined
				},
				set: function (v) {
					var head = this.head,
					    title = this.createElement('title');
					title.appendChild(this.createTextNode(v));
					if (!head)
						return;
					for (var i = 0, heads = head.children, l = heads.length; i < l; ++i) {
						if (heads[i].tag === 'title') {
							head.replaceChild(title, heads[i]);
							return;
						}
					}
					head.appendChild(title);
				},
				enumerable: true,
				configurable: false
			}
		});
		if (type)
			this.appendChild(new DocumentType(type, publicId, systemId));
	}

	for (var key in Element.prototype) {
		if ({appendChild: 1, insertBefore: 1}[key])
			continue;
		Object.defineProperty(Document.prototype, key, Object.getOwnPropertyDescriptor(Element.prototype, key));
	}
	Object.defineProperties(Document.prototype, {
		'adoptNode' : {
			value: function (node) {
				node.parentNode.removeChild(node);
				Object.defineProperty(node, '_ownerDocument', {value: this, writable: false, enumerable: false, configurable: true});
			}
		},
		'appendChild': {
			value: function (elem) {
				for (var i = 0, l =this.childNodes; i < l; ++i)
					if (this.childNodes[i].nodeType === elem.nodeType)
						throw "Only one node of this type can be presented";
				Element.prototype.appendChild.call(this, elem);
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'createComment': {
			value: function (data) {
				var c = new Comment(data);
				c.ownerDocument = this;
				return c;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'createDocumentFragment': {
			value: function () {
				var f = new DocumentFragment();
				f.ownerDocument = this;
				return f;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'createElement': {
			value: function (tag) {
				var elem = new Element(tag, CONSTANTS.ELEMENT_NODE);
				elem.ownerDocument = this;
				return elem;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'createTextNode': {
			value: function (data) {
				var text = new Text(data);
				text.ownerDocument = this;
				return text;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'insertBefore': {
			value: function (newChild, refChild) {
				for (var i = 0, l =this.childNodes; i < l; ++i)
					if (this.childNodes[i].nodeType === elem.nodeType)
						throw "Only one node of this type can be presented";
				Element.prototype.insertBefore.call(this, newChild, refChild);
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'getElementById': {
			value: function (elementId) {
				for (var i = 0, embeds = this.embeds, l = embeds.length; i < l; ++i)
					if (embeds[i].id == elementId)
						return embeds[i];
				return null;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'getElementsByName': {
			value: function (qualifiedName) {
				var res = [];
				for (var i = 0, embeds = this.embeds, l = embeds.length; i < l; ++i) {
					var e = embeds[i];
					if (e.name == qualifiedName)
						res.push(e);
				}
				return res;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'importNode': {
			value: function (node, deep) {
				node = node.cloneNode(deep);
				Element.prototype.appendChild.call(this, elem);
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'toString': Object.getOwnPropertyDescriptor(Node.prototype, 'toString'),
		'drawElement': {
			value: function (element, path, format) {
				var output = new Output(path, (element.ownerDocument || element).charset || this.charset);
				function _draw(elem, format, t) {
					var tabs = [];
					if (!t)
						t = 0;
					for (var i = 0; i < t; ++i)
						tabs.push('\t');
					tabs = tabs.join('');

					switch (format) {
						case 'selenium': t = (elem.tag === 'tr' && 1) || 0; break;
						case 'normal':
						default: ++t; break;
					}

					switch (elem.nodeType) {

						case CONSTANTS.DOCUMENT_NODE:
						case CONSTANTS.DOCUMENT_FRAGMENT_NODE:
							for (var i = 0, l = elem.childNodes.length; i < l; ++i)
								_draw(elem.childNodes[i], format, 0);
							break;

						case CONSTANTS.ELEMENT_NODE:
							if (elem.childNodes.length === 1 && elem.firstChild.nodeType === CONSTANTS.TEXT_NODE) {
								output.printLine(tabs + elem.toString());
								return;
							}
							var str = '<' + elem.tag;
							if (elem.attributes.length)
								str += (' ' + elem.attributes);
							output.printLine(tabs + str + (elem.childNodes.length ? '>' : '/>'));
								
							for (var i = 0, l = elem.childNodes.length; i < l; ++i)
								_draw(elem.childNodes[i], format, t);
							if (elem.childNodes.length)
								output.printLine(tabs + '</' + elem.tag + '>');
							break;

						case CONSTANTS.TEXT_NODE:
						case CONSTANTS.COMMENT_NODE:
						case CONSTANTS.DOCUMENT_TYPE_NODE:
						default: output.printLine(tabs + elem.toString()); break;
					}
				}
				switch (format) {
					case 'oneline': output.printLine(element.toString()); break;
					default: _draw(element, format, 0);
				}
				
			},
			writable: false,
			enumerable: false,
			configurable: false
		},
		'drawDocument': {
			value: function (path, format, xmlInfo) {
				if (xmlInfo) {
					var self = this,
					    data = typeof xmlInfo === 'object' ? xmlInfo : {},
					    info = {
					    	nodeType: -1,
					    	ownerDocument: self,
					    	data: data,
					    	toString: function() {
					    		var str = ['<?xml'];
					    		for (var key in this.data)
					    			str.push(key + '=\"' + this.data[key] + '\"');
					    		str.push('?>');
					    		return str.join(' ');
					    	}
					    };
					data.version = data.version || this.version || '1.0';
					data.encoding = (data.encoding || this.charset || 'UTF-8');
					this.insertBefore(info, this.firstChild);
				}
				this.drawElement(this, path, format);
			},
			writable: false,
			enumerable: false,
			configurable: false
		}
	});

	module.exports = Document;
})()